# ============================================================================
# USER MUTATIONS
# ============================================================================

mutation CreateUser(
  $email: String!
  $firstName: String
  $lastName: String
  $role: String
  $phoneNumber: String
) @auth(level: PUBLIC) {
  user_insert(data: {
    email: $email
    firstName: $firstName
    lastName: $lastName
    role: $role
    phoneNumber: $phoneNumber
  })
}

mutation UpdateUser(
  $id: UUID!
  $firstName: String
  $lastName: String
  $phoneNumber: String
  $lastLoginAt: Timestamp
) {
  user_update(
    id: $id
    data: {
      firstName: $firstName
      lastName: $lastName
      phoneNumber: $phoneNumber
      lastLoginAt: $lastLoginAt
    }
  )
}

mutation UpdateUserPasswordStatus(
  $userId: UUID!
  $hasPassword: Boolean!
  $isTemporary: Boolean!
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by Cloud Functions to update user password status after password setup. Frontend access is controlled through authenticated setupPassword() function."
) {
  user_update(
    id: $userId
    data: {
      hasPassword: $hasPassword
      isTemporary: $isTemporary
    }
  )
}

mutation DeactivateUser($id: UUID!) {
  user_update(
    id: $id
    data: {
      isActive: false
    }
  )
}

mutation UpdateUserRole($userId: UUID!, $role: String!) @auth(
  level: PUBLIC
  insecureReason: "This mutation is intended for use by Firebase Console administrators in GraphQL playground. UI access is restricted to super-admin role."
) {
  user_update(
    id: $userId
    data: {
      role: $role
    }
  )
}

# ============================================================================
# LOAN MUTATIONS
# ============================================================================

mutation CreateLoan(
  $userId: UUID!
  $loanNumber: String!
  $borrowerName: String!
  $borrowerEmail: String
  $loanAmount: Float
  $loanType: String
  $propertyAddress: String
  $loanOfficerId: UUID
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by admin and super-admin users to create loans. Frontend enforces role-based access control via RequireAdmin component."
) {
  loan_insert(data: {
    userId: $userId
    loanNumber: $loanNumber
    borrowerName: $borrowerName
    borrowerEmail: $borrowerEmail
    loanAmount: $loanAmount
    loanType: $loanType
    propertyAddress: $propertyAddress
    loanOfficerId: $loanOfficerId
  })
}

mutation UpdateLoan(
  $id: UUID!
  $status: String
  $notes: String
  $loanAmount: Float
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by admin and super-admin users to update loans. Frontend enforces role-based access control."
) {
  loan_update(
    id: $id
    data: {
      status: $status
      notes: $notes
      loanAmount: $loanAmount
    }
  )
}

mutation CloseLoan($id: UUID!, $closedAt: Timestamp!) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by admin and super-admin users to close loans. Frontend enforces role-based access control."
) {
  loan_update(
    id: $id
    data: {
      status: "closed"
      closedAt: $closedAt
    }
  )
}

mutation DeleteLoan($id: UUID!) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by admin and super-admin users to delete loans. Frontend enforces role-based access control."
) {
  loan_delete(id: $id)
}

# ============================================================================
# FILE MUTATIONS
# ============================================================================

mutation CreateFile(
  $userId: UUID!
  $loanId: UUID
  $originalFilename: String!
  $storagePath: String!
  $fileSize: Int!
  $mimeType: String
  $fileExtension: String
  $downloadUrl: String
  $tags: String
  $description: String
) @auth(level: PUBLIC) {
  file_insert(data: {
    userId: $userId
    loanId: $loanId
    originalFilename: $originalFilename
    storagePath: $storagePath
    fileSize: $fileSize
    mimeType: $mimeType
    fileExtension: $fileExtension
    downloadUrl: $downloadUrl
    tags: $tags
    description: $description
  })
}

mutation UpdateFile(
  $id: UUID!
  $tags: String
  $description: String
  $downloadUrl: String
) @auth(level: PUBLIC) {
  file_update(
    id: $id
    data: {
      tags: $tags
      description: $description
      downloadUrl: $downloadUrl
    }
  )
}

mutation SoftDeleteFile($id: UUID!, $deletedBy: UUID, $deletedAt: Timestamp!) {
  file_update(
    id: $id
    data: {
      isDeleted: true
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

mutation HardDeleteFile($id: UUID!) {
  file_delete(id: $id)
}

mutation RenameFile($id: UUID!, $newFilename: String!) @auth(level: PUBLIC) {
  file_update(
    id: $id
    data: {
      originalFilename: $newFilename
    }
  )
}

mutation MoveFile(
  $id: UUID!
  $targetUserId: UUID!
  $targetLoanId: UUID
) @auth(level: PUBLIC) {
  file_update(
    id: $id
    data: {
      userId: $targetUserId
      loanId: $targetLoanId
    }
  )
}

mutation CopyFile(
  $userId: UUID!
  $loanId: UUID
  $originalFilename: String!
  $storagePath: String!
  $fileSize: Int!
  $mimeType: String
  $fileExtension: String
  $downloadUrl: String
  $tags: String
  $description: String
) @auth(level: PUBLIC) {
  file_insert(data: {
    userId: $userId
    loanId: $loanId
    originalFilename: $originalFilename
    storagePath: $storagePath
    fileSize: $fileSize
    mimeType: $mimeType
    fileExtension: $fileExtension
    downloadUrl: $downloadUrl
    tags: $tags
    description: $description
  })
}

mutation RestoreFile($id: UUID!) @auth(level: PUBLIC) {
  file_update(
    id: $id
    data: {
      isDeleted: false
      deletedAt: null
      deletedBy: null
    }
  )
}

# ============================================================================
# FILE-LOAN ASSOCIATION MUTATIONS
# ============================================================================

mutation AssociateFileWithLoan(
  $fileId: UUID!
  $loanId: UUID!
  $associatedBy: UUID
) {
  fileLoanAssociation_insert(data: {
    fileId: $fileId
    loanId: $loanId
    associatedBy: $associatedBy
  })
}

mutation RemoveFileFromLoan($id: UUID!) {
  fileLoanAssociation_delete(id: $id)
}

# Note: To associate a file with multiple loans, call AssociateFileWithLoan
# multiple times from the frontend, once for each loanId

# ============================================================================
# AUTHENTICATION MUTATIONS
# ============================================================================

mutation CreateAuthSession(
  $sessionId: String!
  $userId: UUID!
  $loanIds: String
  $emailHash: String!
  $magicToken: String
  $expiresAt: Timestamp!
  $ipAddress: String
  $userAgent: String
  $createdBy: UUID
) {
  authSession_insert(data: {
    sessionId: $sessionId
    userId: $userId
    loanIds: $loanIds
    emailHash: $emailHash
    magicToken: $magicToken
    expiresAt: $expiresAt
    ipAddress: $ipAddress
    userAgent: $userAgent
    createdBy: $createdBy
  })
}

# Firebase Email Link Auth session creation
mutation CreateAuthSessionWithFirebase(
  $sessionId: String!
  $userId: UUID!
  $firebaseUid: String!
  $emailHash: String!
  $loanIds: String
  $borrowerContactId: String
  $loanNumber: String
  $expiresAt: Timestamp!
  $ipAddress: String
  $userAgent: String
) @auth(level: PUBLIC) {
  authSession_insert(data: {
    sessionId: $sessionId
    userId: $userId
    firebaseUid: $firebaseUid
    emailHash: $emailHash
    loanIds: $loanIds
    borrowerContactId: $borrowerContactId
    loanNumber: $loanNumber
    status: "pending"
    expiresAt: $expiresAt
    ipAddress: $ipAddress
    userAgent: $userAgent
  })
}

mutation UpdateAuthSession(
  $id: UUID!
  $status: String
  $sessionToken: String
  $verifiedAt: Timestamp
  $lastAccessedAt: Timestamp
) {
  authSession_update(
    id: $id
    data: {
      status: $status
      sessionToken: $sessionToken
      verifiedAt: $verifiedAt
      lastAccessedAt: $lastAccessedAt
    }
  )
}

# Verify and activate Firebase auth session
mutation VerifyAuthSession(
  $id: UUID!
  $sessionToken: String!
  $verifiedAt: Timestamp!
) @auth(level: PUBLIC) {
  authSession_update(
    id: $id
    data: {
      status: "active"
      sessionToken: $sessionToken
      verifiedAt: $verifiedAt
      lastAccessedAt: $verifiedAt
    }
  )
}

# Update session last accessed time
mutation UpdateSessionAccess(
  $id: UUID!
  $lastAccessedAt: Timestamp!
) @auth(level: PUBLIC) {
  authSession_update(
    id: $id
    data: {
      lastAccessedAt: $lastAccessedAt
    }
  )
}

mutation RevokeAuthSession(
  $id: UUID!
  $revokedBy: UUID
  $revokeReason: String
  $revokedAt: Timestamp!
) {
  authSession_update(
    id: $id
    data: {
      status: "revoked"
      revokedAt: $revokedAt
      revokedBy: $revokedBy
      revokeReason: $revokeReason
    }
  )
}

mutation CreateVerificationCode(
  $sessionId: String!
  $codeHash: String!
  $expiresAt: Timestamp!
) {
  verificationCode_insert(data: {
    sessionId: $sessionId
    codeHash: $codeHash
    expiresAt: $expiresAt
  })
}

mutation UpdateVerificationCodeAttempts($id: UUID!, $attemptCount: Int!) {
  verificationCode_update(
    id: $id
    data: {
      attemptCount: $attemptCount
    }
  )
}

mutation MarkVerificationCodeUsed($id: UUID!, $usedAt: Timestamp!) {
  verificationCode_update(
    id: $id
    data: {
      isUsed: true
      usedAt: $usedAt
    }
  )
}

mutation LogAuthEvent(
  $sessionId: String
  $userId: UUID
  $eventType: String!
  $success: Boolean!
  $errorMessage: String
  $errorCode: String
  $ipAddress: String
  $userAgent: String
  $requestPayload: String
) {
  authAuditLog_insert(data: {
    sessionId: $sessionId
    userId: $userId
    eventType: $eventType
    success: $success
    errorMessage: $errorMessage
    errorCode: $errorCode
    ipAddress: $ipAddress
    userAgent: $userAgent
    requestPayload: $requestPayload
  })
}

mutation TrackRateLimit(
  $identifier: String!
  $actionType: String!
  $attemptCount: Int
  $blockedUntil: Timestamp
) {
  rateLimitTracking_insert(data: {
    identifier: $identifier
    actionType: $actionType
    attemptCount: $attemptCount
    blockedUntil: $blockedUntil
  })
}

mutation UpdateRateLimit(
  $id: UUID!
  $attemptCount: Int!
  $blockedUntil: Timestamp
) {
  rateLimitTracking_update(
    id: $id
    data: {
      attemptCount: $attemptCount
      blockedUntil: $blockedUntil
    }
  )
}

mutation DeleteExpiredSessions($currentTime: Timestamp!) {
  authSession_deleteMany(
    where: {
      expiresAt: { lt: $currentTime }
      status: { eq: "pending" }
    }
  )
}

mutation DeleteExpiredVerificationCodes($currentTime: Timestamp!) {
  verificationCode_deleteMany(
    where: {
      expiresAt: { lt: $currentTime }
    }
  )
}

# ============================================================================
# MAGIC LINK MUTATIONS
# ============================================================================

mutation CreateMagicLink(
  $userId: UUID!
  $borrowerEmail: String!
  $sendToEmail: String!
  $magicLinkUrl: String!
  $sessionId: String
  $expiresAt: Timestamp!
  $createdBy: UUID
  $sentAt: Timestamp
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by Cloud Functions to create magic links. Frontend access is controlled through authenticated Cloud Function."
) {
  magicLink_insert(data: {
    userId: $userId
    borrowerEmail: $borrowerEmail
    sendToEmail: $sendToEmail
    magicLinkUrl: $magicLinkUrl
    sessionId: $sessionId
    expiresAt: $expiresAt
    createdBy: $createdBy
    sentAt: $sentAt
  })
}

mutation UpdateMagicLinkSendCount(
  $id: UUID!
  $sendCount: Int!
  $lastSentAt: Timestamp!
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by admin users to track magic link resends. Frontend enforces role-based access control."
) {
  magicLink_update(
    id: $id
    data: {
      sendCount: $sendCount
      lastSentAt: $lastSentAt
    }
  )
}

mutation RevokeMagicLink(
  $id: UUID!
  $revokedAt: Timestamp!
  $revokedBy: UUID
  $revokeReason: String
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by admin users to revoke magic links. Frontend enforces role-based access control."
) {
  magicLink_update(
    id: $id
    data: {
      isActive: false
      revokedAt: $revokedAt
      revokedBy: $revokedBy
      revokeReason: $revokeReason
    }
  )
}

mutation MarkMagicLinkUsed(
  $sessionId: String!
  $usedAt: Timestamp!
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by Cloud Functions when a user signs in with a magic link. Frontend access is controlled through authenticated Cloud Function."
) {
  magicLink_updateMany(
    where: { sessionId: { eq: $sessionId } }
    data: {
      usedAt: $usedAt
      isActive: false
    }
  )
}

mutation ExtendMagicLink(
  $id: UUID!
  $expiresAt: Timestamp!
) @auth(
  level: PUBLIC
  insecureReason: "This mutation is used by admin users to extend magic link expiry. Frontend enforces role-based access control."
) {
  magicLink_update(
    id: $id
    data: {
      expiresAt: $expiresAt
    }
  )
}
